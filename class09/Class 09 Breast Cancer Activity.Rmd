---
title: "Class 9: Breast_cancer_activity"
output: github_document
always_allow_html: yes
---

# Part 1: Explore our dataset and format it for analysis downstream

```{r }

# read in our data file and save it to a dataframe
fna.data <- "WisconsinCancer.csv"

wisc.df <- read.csv(file = fna.data, header = TRUE, sep = ",")

head(wisc.df)


```
```{r}

## how many of each diagnosis 

table(wisc.df$diagnosis)

# we have 357 benign and 212 malignant


```

```{r}

## how many patients 

dim(wisc.df)

# 569 patients 

```


```{r}

# How many variables/features in the data are suffixed with _mean? 

length(grep("_mean", colnames(wisc.df)))

# 10


```


Instructions: Next use as.matrix() to convert the other features (i.e. columns) of the data (in columns 3 through 32) to a matrix. Store this in a variable called wisc.data.


```{r}

# remove the last column of the dataset 

data_for_matrix <- wisc.df[,3:32]

wisc.data <- as.matrix(data_for_matrix)

head(wisc.data)

```

If you have not already done so, now would be a good time to assign the row names of wisc.data the values currently contained in the id column of wisc.df. While not strictly required, this will help you keep track of the different observations throughout the modeling process.

```{r}

row.names(wisc.data) <- wisc.df$id

head(wisc.data)


```


Instructions: Finally, setup a separate new vector called diagnosis that contains the data from the diagnosis column of the original dataset. We will use this later to check our results as we aim to discriminate benign from malignant cancerous cells.


```{r}

diagnosis <- wisc.df$diagnosis


```

# Principal Component Analysis

Check the mean and standard deviation of the features (i.e. columns) of the wisc.data to determine if the data should be scaled. Use the colMeans() and apply() functions like you've done before.

```{r}

colMeans(wisc.data)

round (apply(wisc.data,2,mean), 1)

round (apply(wisc.data,2,sd), 1)

```


Execute PCA with the prcomp() function on the wisc.data, scaling if appropriate, and assign the output model to  wisc.pr.


```{r}

# run principle component analysis and include scaling 

wisc.pr <- prcomp(wisc.data, scale = TRUE)

# inspect the results of the PCA 

summary(wisc.pr)

```

# Create a BiPlot

This is a common way to visualize principle compnent analyis

```{r}

biplot(wisc.pr)

```

This figure is hard to interpret, instead we will plot the patients across two principal components 

Also will color points by the diagnosis vector we created above 

```{r}

plot(wisc.pr$x[,1],wisc.pr$x[,2] , col = diagnosis, xlab = "PC1", ylab = "PC2")
#text(wisc.pr$x[,1], wisc.pr$x[,2], colnames(x))

```

Create a similar plot but this time plot across principle components 1 and 3 

```{r}
plot(wisc.pr$x[,2],wisc.pr$x[,3], col = diagnosis, 
     xlab = "PC1", ylab = "PC3")
```

# Creating scree plots to explain variance
First we will calculate variance of each principle component by suarting the standard deviation of wisc.pr

```{r}
pr.var <- wisc.pr$sdev^2

#observe the variable we created
head(pr.var)
```

Calculate the variance explained by each principal component by dividing by the total variance explained of all principal components. Assign this to a variable called pve and create a plot of variance explained for each principal component.

```{r}
# Variance explained by each principal component: pve
var_sum <- sum(pr.var)
pve <- pr.var / var_sum

# Plot variance explained for each principal component
plot(pve, xlab = "Principal Component", 
     ylab = "Proportion of Variance Explained", 
     ylim = c(0, 1), type = "o")
```


Create a scree barplot to find the elbow 
```{r}
# Alternative scree plot of the same data, note data driven y-axis
par(mar=c(4,4,4,4))
barplot(pve, ylab = "Percent of Variance Explained",
     names.arg=paste0("PC",1:length(pve)), las=2, axes = FALSE, cex.names = .5)
axis(2, at=pve, labels=round(pve,2)*100 )
```

```{r}
## ggplot based graph
#install.packages("factoextra")
library(factoextra)
fviz_eig(wisc.pr, addlabels = TRUE)
```

```{r}
max(abs(wisc.pr$rotation[,1]))
wisc.pr$rotation[,1]
```


#Hierarchical clustering of case data

We are going to to see if natural groups exist in our diagnosis data

Scale the wisc.data data.

```{r}
# Scale the wisc.data data: data.scaled
data.scaled <- scale(wisc.data)


data.dist <- dist(data.scaled)


wisc.hclust <- hclust(data.dist, method= "complete")

```

Plot the results of hierarchical clustering 
Create a line where there are 4 clusters. 

```{r}
plot(wisc.hclust)
abline(h=19, col="red", lty=2)
```

We are going to compare our hierarchical clustering model to the diagnoses we have. We can then check to see if our unsupervised model is good at predicting our target variable. 

First we are using cutree to make it have 4 clusters 

```{r}
wisc.hclust.clusters <- cutree(wisc.hclust, k=4 ) 

# compare our clusters to our known patient diagnoses 

table(wisc.hclust.clusters, diagnosis)


```


Our current model does a pretty good job of matching the true diagnoses, but let's try different numbers of clusters to see if we can get a better match. 

```{r}

wisc.hclust.clusters_new <- cutree(wisc.hclust, k=3) 

# compare our clusters to our known patient diagnoses 

table(wisc.hclust.clusters_new, diagnosis)

```


# K-means clustering 

In this section, you will create a k-means clustering model on the Wisconsin breast cancer data and compare the results to the actual diagnoses and the results of your hierarchical clustering model. 

Create a k-means model on wisc.data, assigning the result to wisc.km. Be sure to create 2 clusters, corresponding to the actual number of diagnosis. 

```{r}
wisc.km <- kmeans(wisc.data, centers= 2, nstart= 212)

table(wisc.km$cluster, diagnosis)



```

```{r}
# compare cluster model to k-means model

table(wisc.km$cluster, wisc.hclust.clusters)
```



# Combining methods

Does using PCA improve the clustering methods?

Using the minimum number of principal components required to describe at least 90% of the variability in the data, create a hierarchical clustering model with the linkage method="ward.D2". We use Ward's criterion here because it is based on multidimensional variance like principal components analysis

```{r}
#want pc that combine to make 90% of the variability, that is PC1-PC7

wisc.pr.hclust <- hclust(dist(wisc.pr$x[,1:7]), method= "ward.D2")


grps <- cutree(wisc.pr.hclust, k=2)
table(grps)



```

Compare this to diagnosis 

```{r}

table(grps, diagnosis)

```

```{r}

# plot by principal components, color by the clustering
plot(wisc.pr$x[,1:2], col=grps)


```

```{r}
# plot again but this time color by diagnosis

plot(wisc.pr$x[,1:2], col=diagnosis)
```

Note the color swap here as the hclust cluster 1 is mostly "M" and cluster 2 is mostly "B" as we saw from the results of calling  table(grps, diagnosis). To match things up we can turn our groups into a factor and reorder the levels so cluster 2 comes first

```{r}

g <- as.factor(grps)
levels(g)

```

```{r}
g <- relevel(g,2)
levels(g)

```


```{r}

# Plot using our re-ordered factor 
plot(wisc.pr$x[,1:2], col=g)

```

Lets be fancy and look in 3D with the rgl package we learned about in a previous class. 

Note! Need XQuartz open on Mac to run 

```{r}

library(rgl)

plot3d(wisc.pr$x[,1:3], xlab="PC 1", ylab="PC 2", zlab="PC 3", cex=1.5, size=1, type="s", col=grps)

# in order to view in RStudio run this code

rglwidget(width = 400, height = 400)

```

# Prediction

Predicting Malignancy Of New samples using the model we created. 
```{r}

## Read in data from this web-link

url <- "https://tinyurl.com/new-samples-CSV"
new <- read.csv(url)

# use the principal components we created to predict the diagnosis of these patients 
npc <- predict(wisc.pr, newdata=new)
npc



```


```{r}

# Plot the new points across the first two principle components 

plot(wisc.pr$x[,1:2], col=g)
points(npc[,1], npc[,2], col="blue", pch=16, cex=3)

# label the clusters that the model predicts 
text(npc[,1], npc[,2], c(1,2), col="white")

```

We would take patients in group 2 to analyze for further analysis because they have similar profiles to know cancer diagnosed patients.


As, always, save our session information for reporducibility 

```{r}
sessionInfo()
```

